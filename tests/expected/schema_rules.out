-- Test for S001 and S002 schema rules
BEGIN;
DROP EXTENSION IF EXISTS pglinter CASCADE;
NOTICE:  extension "pglinter" does not exist, skipping
-- Create test schemas that should trigger S002 (environment prefixes/suffixes)
CREATE SCHEMA prod_sales;
CREATE SCHEMA dev_analytics;
CREATE SCHEMA testing_data;
CREATE SCHEMA reports_staging;
-- Create a clean schema that should not trigger rules
CREATE SCHEMA business_logic;
-- Create some objects in the schemas to make them more realistic
CREATE TABLE prod_sales.customers (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL
);
CREATE TABLE dev_analytics.metrics (
    id SERIAL PRIMARY KEY,
    metric_name TEXT NOT NULL,
    value NUMERIC
);
CREATE TABLE business_logic.rules (
    id SERIAL PRIMARY KEY,
    rule_name TEXT NOT NULL
);
CREATE EXTENSION IF NOT EXISTS pglinter;
-- Test the schema rules
SELECT 'Testing schema rules S001 and S002...' as test_info;
               test_info               
---------------------------------------
 Testing schema rules S001 and S002...
(1 row)

-- Run schema check to detect environment-named schemas and default privilege issues
SELECT pglinter.perform_schema_check();
WARNING:  pglinter schema check failed: S001 failed: Database error: Datum error: Postgres type name (Oid(19)) is not compatible with the Rust type alloc::string::String (Oid(25))
 perform_schema_check 
----------------------
 f
(1 row)

-- Test individual schema rules
SELECT pglinter.explain_rule('S001');
NOTICE:  üìñ Rule Explanation for S001
============================================================

üéØ Rule Name: SchemaWithDefaultRoleNotGranted
üìã Scope: SCHEMA

üìù Description:
The schema ha no default role. Means that futur table will not be granted through a role. So you will have to re-execute grants on it.

‚ö†Ô∏è  Message Template:
No default role grantee on schema {0}.{1}. It means that each time a table is created, you must grant it to roles.

üîß How to Fix:
   1. add a default privilege=> ALTER DEFAULT PRIVILEGES IN SCHEMA <schema> for user <schema's owner>
============================================================
 explain_rule 
--------------
 t
(1 row)

SELECT pglinter.explain_rule('S002');
NOTICE:  üìñ Rule Explanation for S002
============================================================

üéØ Rule Name: SchemaPrefixedOrSuffixedWithEnvt
üìã Scope: SCHEMA

üìù Description:
The schema is prefixed with one of staging,stg,preprod,prod,sandbox,sbox string. Means that when you refresh your preprod, staging environments from production, you have to rename the target schema from prod_ to stg_ or something like. It is possible, but it is never easy.

‚ö†Ô∏è  Message Template:
You should not prefix or suffix the schema name with {0}. You may have difficulties when refreshing environments. Prefer prefix or suffix the database name.

üîß How to Fix:
   1. Keep the same schema name across environments. Prefer prefix or suffix the database name
============================================================
 explain_rule 
--------------
 t
(1 row)

-- Test rule management for schema rules
SELECT pglinter.is_rule_enabled('S001') AS s001_enabled;
 s001_enabled 
--------------
 t
(1 row)

SELECT pglinter.is_rule_enabled('S002') AS s002_enabled;
 s002_enabled 
--------------
 t
(1 row)

-- Test disabling S002 (environment prefixes)
SELECT pglinter.disable_rule('S002') AS s002_disabled;
NOTICE:  üî¥ Rule S002 has been disabled
 s002_disabled 
---------------
 t
(1 row)

SELECT pglinter.perform_schema_check(); -- Should skip S002
WARNING:  pglinter schema check failed: S001 failed: Database error: Datum error: Postgres type name (Oid(19)) is not compatible with the Rust type alloc::string::String (Oid(25))
 perform_schema_check 
----------------------
 f
(1 row)

-- Re-enable S002
SELECT pglinter.enable_rule('S002') AS s002_reenabled;
NOTICE:  ‚úÖ Rule S002 has been enabled
 s002_reenabled 
----------------
 t
(1 row)

SELECT pglinter.perform_schema_check(); -- Should include S002 again
WARNING:  pglinter schema check failed: S001 failed: Database error: Datum error: Postgres type name (Oid(19)) is not compatible with the Rust type alloc::string::String (Oid(25))
 perform_schema_check 
----------------------
 f
(1 row)

-- Test the comprehensive check including schemas
SELECT pglinter.check_all();
NOTICE:  üîç Running comprehensive pglinter check...
NOTICE:  
NOTICE:  üìã BASE CHECKS:
NOTICE:  üîç pglinter found 3 issue(s):
NOTICE:  ==================================================
NOTICE:  ‚ö†Ô∏è  [B001] WARNING: 1 tables without primary key exceed the warning threshold: 10%
NOTICE:  ‚ö†Ô∏è  [B004] WARNING: Found 4 potentially unused indexes
NOTICE:  ‚ùå [B005] ERROR: Public schema allows CREATE privilege for all users - security risk
NOTICE:  ==================================================
NOTICE:  üìä Summary: 1 error(s), 2 warning(s), 0 info
NOTICE:  üî¥ Critical issues found - please review and fix errors
NOTICE:  
NOTICE:  üñ•Ô∏è  CLUSTER CHECKS:
NOTICE:  üîç pglinter found 1 issue(s):
NOTICE:  ==================================================
NOTICE:  ‚ÑπÔ∏è  [C002] INFO: Please manually check pg_hba.conf for insecure trust/password methods
NOTICE:  ==================================================
NOTICE:  üìä Summary: 0 error(s), 0 warning(s), 1 info
NOTICE:  üü¢ Only informational messages - good job!
NOTICE:  
NOTICE:  üìä TABLE CHECKS:
ERROR:  missing FROM-clause entry for table "i"
LINE 3:             array_agg(i.indexname) as redundant_indexes
                              ^
QUERY:  
        SELECT t.schemaname, t.tablename,
            array_agg(i.indexname) as redundant_indexes
        FROM (
            SELECT DISTINCT i1.schemaname, i1.tablename, i1.indexname
            FROM pg_indexes i1
            JOIN pg_indexes i2 ON i1.schemaname = i2.schemaname
                AND i1.tablename = i2.tablename
                AND i1.indexname != i2.indexname
            WHERE i1.schemaname NOT IN ('pg_toast', 'pg_catalog', 'information_schema')
            AND EXISTS (
                SELECT 1 FROM pg_index idx1, pg_index idx2, pg_class c1, pg_class c2
                WHERE c1.relname = i1.indexname AND c2.relname = i2.indexname
                AND idx1.indexrelid = c1.oid AND idx2.indexrelid = c2.oid
                AND idx1.indrelid = idx2.indrelid
                AND idx1.indkey = idx2.indkey
            )
        ) t
        GROUP BY t.schemaname, t.tablename
-- Clean up schemas
DROP SCHEMA prod_sales CASCADE;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
DROP SCHEMA dev_analytics CASCADE;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
DROP SCHEMA testing_data CASCADE;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
DROP SCHEMA reports_staging CASCADE;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
DROP SCHEMA business_logic CASCADE;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
ROLLBACK;

-- Test for T003 rule - Tables with redundant indexes
BEGIN;
DROP EXTENSION IF EXISTS pglinter CASCADE;
NOTICE:  extension "pglinter" does not exist, skipping
-- Create test table with redundant indexes
CREATE TABLE test_table_redundant (
    id INT,
    name TEXT,
    email TEXT,
    status TEXT
);
-- Create multiple indexes on the same column (redundant)
CREATE INDEX idx_name_1 ON test_table_redundant(name);
CREATE INDEX idx_name_2 ON test_table_redundant(name); -- redundant with idx_name_1
-- Create composite indexes with same columns (redundant)
CREATE INDEX idx_composite_1 ON test_table_redundant(email, status);
CREATE INDEX idx_composite_2 ON test_table_redundant(email, status); -- redundant with idx_composite_1
-- Create another test table
CREATE TABLE test_table_clean (
    id SERIAL PRIMARY KEY,
    description TEXT
);
-- This index is unique, not redundant
CREATE UNIQUE INDEX idx_clean_desc ON test_table_clean(description);
CREATE EXTENSION IF NOT EXISTS pglinter;
-- Test the T003 rule specifically
SELECT 'Testing T003 rule...' as test_info;
      test_info       
----------------------
 Testing T003 rule...
(1 row)

-- Run table check to see redundant indexes
SELECT pglinter.perform_table_check();
ERROR:  missing FROM-clause entry for table "i"
LINE 3:             array_agg(i.indexname) as redundant_indexes
                              ^
QUERY:  
        SELECT t.schemaname, t.tablename,
            array_agg(i.indexname) as redundant_indexes
        FROM (
            SELECT DISTINCT i1.schemaname, i1.tablename, i1.indexname
            FROM pg_indexes i1
            JOIN pg_indexes i2 ON i1.schemaname = i2.schemaname
                AND i1.tablename = i2.tablename
                AND i1.indexname != i2.indexname
            WHERE i1.schemaname NOT IN ('pg_toast', 'pg_catalog', 'information_schema')
            AND EXISTS (
                SELECT 1 FROM pg_index idx1, pg_index idx2, pg_class c1, pg_class c2
                WHERE c1.relname = i1.indexname AND c2.relname = i2.indexname
                AND idx1.indexrelid = c1.oid AND idx2.indexrelid = c2.oid
                AND idx1.indrelid = idx2.indrelid
                AND idx1.indkey = idx2.indkey
            )
        ) t
        GROUP BY t.schemaname, t.tablename
-- Test rule management
SELECT pglinter.explain_rule('T003');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
-- Test enabling/disabling T003
SELECT pglinter.is_rule_enabled('T003') AS t003_initially_enabled;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SELECT pglinter.disable_rule('T003') AS t003_disabled;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SELECT pglinter.is_rule_enabled('T003') AS t003_after_disable;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
-- Run check again (should skip T003)
SELECT pglinter.perform_table_check();
ERROR:  current transaction is aborted, commands ignored until end of transaction block
-- Re-enable T003
SELECT pglinter.enable_rule('T003') AS t003_enabled;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SELECT pglinter.is_rule_enabled('T003') AS t003_after_enable;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
-- Final check with T003 enabled
SELECT pglinter.perform_table_check();
ERROR:  current transaction is aborted, commands ignored until end of transaction block
-- Clean up
DROP TABLE test_table_redundant CASCADE;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
DROP TABLE test_table_clean CASCADE;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
ROLLBACK;
